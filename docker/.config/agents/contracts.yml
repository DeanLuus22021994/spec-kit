# yaml-language-server: $schema=../schemas/config.schema.json
# Agent Responsibility Contracts & Interface Definitions
# Defines clear boundaries, contracts, and responsibilities for each agent

_definitions:
  metadata: &metadata
    name: "agent-contracts"
    description: "Agent Responsibility Contracts & Interface Definitions"
    version: "1.0.0"
    updated: "2025-11-25"
    category: config
    keywords:
      [
        agents,
        contracts,
        interfaces,
        boundaries,
        responsibilities,
        soap,
        wsdl,
        orchestration,
      ]

  protocols:
    http: &http_proto "HTTP/REST"
    soap: &soap_proto "SOAP"
    grpc: &grpc_proto "gRPC"
    redis: &redis_proto "Redis"

  tiers:
    core: &tier_core "core"
    ai: &tier_ai "ai"
    business: &tier_business "business"

  boundaries:
    standard: &std_boundaries
      timeout_ms: 30000
      retry_policy:
        max_retries: 3
        backoff_multiplier: 2.0

  interfaces:
    standard_inbound: &std_inbound
      - protocol: *http_proto
        methods: ["POST"]
      - protocol: *soap_proto

metadata: *metadata

description: |
  Enterprise agent architecture with clear responsibility contracts,
  interface definitions, and operational boundaries for the Semantic Kernel platform.
  Supports SOAP/WSDL 3rd party integration with multi-agent orchestration.

# =============================================================================
# Agent Registry
# =============================================================================
agents:
  orchestrator:
    id: "agent-orchestrator"
    name: "Orchestrator Agent"
    version: "1.0.0"
    tier: *tier_core

    responsibility: |
      Primary coordination agent responsible for decomposing complex tasks,
      routing to specialized agents, aggregating results, and managing
      multi-agent workflows. Acts as the central nervous system for all
      agent-based operations.

    sub_tasks:
      task_decomposition:
        description: "Decompose complex user requests into executable sub-tasks"
        input: { required: ["user_request"], optional: ["context"] }
        output: { fields: ["execution_plan", "dependency_graph"] }

      agent_routing:
        description: "Route sub-tasks to appropriate specialized agents"
        input: { required: ["sub_task", "available_agents"] }
        output: { fields: ["target_agent_id", "routing_strategy"] }

      result_aggregation:
        description: "Synthesize results from multiple agents into final response"
        input: { required: ["partial_results"] }
        output: { fields: ["final_response", "confidence_score"] }

      workflow_coordination:
        description: "Manage state and flow of multi-step agent processes"
        input: { required: ["workflow_id", "current_state"] }
        output: { fields: ["next_action", "state_update"] }

      error_recovery:
        description: "Handle agent failures and attempt recovery strategies"
        input: { required: ["error_context", "failed_step"] }
        output: { fields: ["recovery_action", "retry_status"] }

    interfaces:
      inbound:
        - protocol: *http_proto
          endpoint: "/api/orchestrator/execute"
          methods: ["POST"]
        - protocol: *soap_proto
          endpoint: "/soap/orchestrator"
          wsdl: "/wsdl/orchestrator.wsdl"
        - protocol: *grpc_proto
          service: "OrchestratorService"
      outbound:
        - { target: "semantic-agent", protocol: *http_proto }
        - { target: "embedding-agent", protocol: *http_proto }
        - { target: "retrieval-agent", protocol: *http_proto }
        - { target: "validation-agent", protocol: *http_proto }

    contracts:
      input:
        task_request:
          required: ["task_id", "task_type", "payload"]
          optional: ["priority", "timeout_ms", "callback_url"]
      output:
        task_result:
          fields:
            ["task_id", "status", "result", "execution_time_ms", "agent_trace"]

    boundaries:
      <<: *std_boundaries
      max_concurrent_tasks: 100
      max_task_depth: 10
      timeout_ms: 300000 # Override standard

    dependencies:
      required: ["redis", "database"]
      optional: ["jaeger"]

  semantic:
    id: "agent-semantic"
    name: "Semantic Processing Agent"
    version: "1.0.0"
    tier: *tier_ai

    responsibility: |
      Handles natural language understanding, semantic analysis,
      intent classification, and context management. Processes
      user queries and generates semantic representations.

    sub_tasks:
      intent_classification:
        description: "Identify user intent from natural language input"
        input: { required: ["text"] }
        output: { fields: ["intent_label", "confidence"] }

      entity_extraction:
        description: "Extract named entities and parameters"
        input: { required: ["text"] }
        output: { fields: ["entities", "spans"] }

      sentiment_analysis:
        description: "Analyze emotional tone of input"
        input: { required: ["text"] }
        output: { fields: ["sentiment_score", "label"] }

      context_management:
        description: "Maintain and update conversation context"
        input: { required: ["session_id", "new_interaction"] }
        output: { fields: ["updated_context"] }

    interfaces:
      inbound:
        - protocol: *http_proto
          endpoint: "/api/semantic/process"
          methods: ["POST"]
        - protocol: *soap_proto
          endpoint: "/soap/semantic"
          wsdl: "/wsdl/semantic.wsdl"
      outbound:
        - { target: "embedding-agent", protocol: *http_proto }
        - { target: "llm-provider", protocol: *http_proto }

    contracts:
      input:
        semantic_request:
          required: ["text", "operation"]
          optional: ["context_id", "language", "options"]
      output:
        semantic_result:
          fields: ["intent", "entities", "confidence", "context_id"]

    boundaries:
      <<: *std_boundaries
      max_text_length: 32000
      rate_limit: "100/minute"

    dependencies:
      required: ["engine", "embeddings"]
      optional: ["redis"]

  embedding:
    id: "agent-embedding"
    name: "Embedding Generation Agent"
    version: "1.0.0"
    tier: *tier_ai
    gpu_required: true

    responsibility: |
      GPU-accelerated embedding generation for text, documents,
      and code. Manages embedding model lifecycle and provides
      efficient batch processing capabilities.

    sub_tasks:
      text_embedding:
        description: "Generate vector embeddings for text strings"
        input: { required: ["text"] }
        output: { fields: ["vector"] }

      document_embedding:
        description: "Chunk and embed large documents"
        input: { required: ["document_content"] }
        output: { fields: ["chunk_vectors", "metadata"] }

      batch_processing:
        description: "Process multiple embedding requests efficiently"
        input: { required: ["items_list"] }
        output: { fields: ["vectors_list"] }

    interfaces:
      inbound:
        - protocol: *http_proto
          endpoint: "/api/embeddings/generate"
          methods: ["POST"]
        - protocol: *soap_proto
          endpoint: "/soap/embeddings"
          wsdl: "/wsdl/embeddings.wsdl"
      outbound:
        - { target: "vector-store", protocol: *http_proto }
        - { target: "cache", protocol: *redis_proto }

    contracts:
      input:
        embedding_request:
          required: ["texts"]
          optional: ["model", "batch_size", "normalize"]
      output:
        embedding_result:
          fields: ["embeddings", "dimensions", "model_used", "tokens_processed"]

    boundaries:
      <<: *std_boundaries
      max_batch_size: 100
      max_text_length: 8192
      timeout_ms: 60000 # Override
      gpu_memory_fraction: 0.40

    dependencies:
      required: ["embeddings-service", "redis"]
      optional: ["vector"]

  retrieval:
    id: "agent-retrieval"
    name: "Retrieval Agent"
    version: "1.0.0"
    tier: *tier_ai

    responsibility: |
      Handles vector similarity search, document retrieval,
      and RAG (Retrieval Augmented Generation) operations.
      Manages retrieval strategies and result ranking.

    sub_tasks:
      vector_search:
        description: "Perform semantic search using vector similarity"
        input: { required: ["query_vector"] }
        output: { fields: ["matches", "scores"] }

      hybrid_search:
        description: "Combine keyword and vector search results"
        input: { required: ["query_text", "query_vector"] }
        output: { fields: ["ranked_results"] }

      reranking:
        description: "Re-rank retrieved results for relevance"
        input: { required: ["candidates", "query"] }
        output: { fields: ["reranked_list"] }

    interfaces:
      inbound:
        - protocol: *http_proto
          endpoint: "/api/retrieval/search"
          methods: ["POST"]
        - protocol: *soap_proto
          endpoint: "/soap/retrieval"
          wsdl: "/wsdl/retrieval.wsdl"
      outbound:
        - { target: "vector-store", protocol: *http_proto }
        - { target: "embedding-agent", protocol: *http_proto }

    contracts:
      input:
        retrieval_request:
          required: ["query"]
          optional: ["top_k", "filters", "threshold", "collections"]
      output:
        retrieval_result:
          fields: ["results", "total_count", "search_time_ms"]

    boundaries:
      <<: *std_boundaries
      max_top_k: 100
      timeout_ms: 10000 # Override
      min_threshold: 0.5

    dependencies:
      required: ["vector", "embeddings"]
      optional: ["redis"]

  generation:
    id: "agent-generation"
    name: "Generation Agent"
    version: "1.0.0"
    tier: *tier_ai

    responsibility: |
      Handles text generation, completion, and response synthesis.
      Manages LLM interactions, prompt engineering, and output
      quality control including hallucination detection.

    sub_tasks:
      text_generation:
        description: "Generate text from prompt"
        input: { required: ["prompt"] }
        output: { fields: ["generated_text"] }

      summarization:
        description: "Summarize input text"
        input: { required: ["text", "length_constraint"] }
        output: { fields: ["summary"] }

      hallucination_check:
        description: "Verify generated content against source"
        input: { required: ["generated_text", "source_context"] }
        output: { fields: ["is_grounded", "citations"] }

    interfaces:
      inbound:
        - protocol: *http_proto
          endpoint: "/api/generation/complete"
          methods: ["POST"]
        - protocol: *soap_proto
          endpoint: "/soap/generation"
          wsdl: "/wsdl/generation.wsdl"
      outbound:
        - { target: "llm-provider", protocol: *http_proto }
        - { target: "retrieval-agent", protocol: *http_proto }

    contracts:
      input:
        generation_request:
          required: ["prompt"]
          optional: ["max_tokens", "temperature", "context", "system_prompt"]
      output:
        generation_result:
          fields:
            ["response", "tokens_used", "finish_reason", "grounding_score"]

    boundaries:
      <<: *std_boundaries
      max_prompt_tokens: 8000
      max_output_tokens: 4000
      timeout_ms: 60000 # Override
      temperature_range: [0.0, 2.0]

    dependencies:
      required: ["engine"]
      optional: ["retrieval-agent", "redis"]

  validation:
    id: "agent-validation"
    name: "Validation Agent"
    version: "1.0.0"
    tier: *tier_business

    responsibility: |
      Ensures data quality, schema compliance, and business rule
      validation. Validates inputs, outputs, and intermediate
      results throughout the agent pipeline.

    sub_tasks:
      schema_validation:
        description: "Validate data against JSON/YAML schemas"
        input: { required: ["data", "schema_id"] }
        output: { fields: ["is_valid", "validation_errors"] }

      business_rule_validation:
        description: "Apply domain-specific business rules"
        input: { required: ["data", "rule_set"] }
        output: { fields: ["passed", "violations"] }

      pii_detection:
        description: "Detect and flag PII in data"
        input: { required: ["text"] }
        output: { fields: ["detected_pii_types", "locations"] }

    interfaces:
      inbound:
        - protocol: *http_proto
          endpoint: "/api/validation/validate"
          methods: ["POST"]
        - protocol: *soap_proto
          endpoint: "/soap/validation"
          wsdl: "/wsdl/validation.wsdl"
      outbound:
        - { target: "rules-engine", protocol: *http_proto }

    contracts:
      input:
        validation_request:
          required: ["data", "rules"]
          optional: ["strict_mode", "include_warnings"]
      output:
        validation_result:
          fields: ["valid", "errors", "warnings", "score"]

    boundaries:
      <<: *std_boundaries
      max_payload_size: "10MB"
      timeout_ms: 5000 # Override

    dependencies:
      required: ["business"]
      optional: ["redis"]

# =============================================================================
# SOAP/WSDL Service Definitions
# =============================================================================
soap_services:
  enabled: true
  base_url: "/soap"
  wsdl_base_url: "/wsdl"

  services:
    orchestrator:
      name: "OrchestratorService"
      namespace: "http://semantic-kernel.local/orchestrator"
      endpoint: "/soap/orchestrator"
      wsdl: "/wsdl/orchestrator.wsdl"
      operations:
        - name: "ExecuteTask"
          input: "ExecuteTaskRequest"
          output: "ExecuteTaskResponse"
          faults: ["TaskFault", "TimeoutFault"]
        - name: "GetTaskStatus"
          input: "GetTaskStatusRequest"
          output: "GetTaskStatusResponse"
          faults: ["TaskNotFoundFault"]
        - name: "CancelTask"
          input: "CancelTaskRequest"
          output: "CancelTaskResponse"
          faults: ["TaskFault"]

    semantic:
      name: "SemanticService"
      namespace: "http://semantic-kernel.local/semantic"
      endpoint: "/soap/semantic"
      wsdl: "/wsdl/semantic.wsdl"
      operations:
        - name: "ProcessText"
          input: "ProcessTextRequest"
          output: "ProcessTextResponse"
          faults: ["ProcessingFault"]
        - name: "ClassifyIntent"
          input: "ClassifyIntentRequest"
          output: "ClassifyIntentResponse"
          faults: ["ClassificationFault"]

    embeddings:
      name: "EmbeddingsService"
      namespace: "http://semantic-kernel.local/embeddings"
      endpoint: "/soap/embeddings"
      wsdl: "/wsdl/embeddings.wsdl"
      operations:
        - name: "GenerateEmbeddings"
          input: "GenerateEmbeddingsRequest"
          output: "GenerateEmbeddingsResponse"
          faults: ["EmbeddingFault", "ResourceFault"]

    retrieval:
      name: "RetrievalService"
      namespace: "http://semantic-kernel.local/retrieval"
      endpoint: "/soap/retrieval"
      wsdl: "/wsdl/retrieval.wsdl"
      operations:
        - name: "Search"
          input: "SearchRequest"
          output: "SearchResponse"
          faults: ["SearchFault"]
        - name: "HybridSearch"
          input: "HybridSearchRequest"
          output: "HybridSearchResponse"
          faults: ["SearchFault"]

  message_types:
    ExecuteTaskRequest:
      elements:
        - name: "taskId"
          type: "string"
          required: true
        - name: "taskType"
          type: "string"
          required: true
        - name: "payload"
          type: "base64Binary"
          required: true
        - name: "priority"
          type: "int"
          required: false
          default: 5
        - name: "timeoutMs"
          type: "int"
          required: false
          default: 30000

    ExecuteTaskResponse:
      elements:
        - name: "taskId"
          type: "string"
        - name: "status"
          type: "string"
        - name: "result"
          type: "base64Binary"
        - name: "executionTimeMs"
          type: "long"

# =============================================================================
# Inter-Agent Communication Protocol
# =============================================================================
communication:
  protocol: "AMQP"
  fallback: "HTTP/REST"

  message_format:
    version: "1.0"
    encoding: "JSON"
    compression: "gzip"

  headers:
    required:
      - "X-Correlation-Id"
      - "X-Agent-Id"
      - "X-Timestamp"
    optional:
      - "X-Priority"
      - "X-Callback-Url"
      - "X-Trace-Id"

  error_handling:
    retry_policy:
      max_retries: 3
      initial_delay_ms: 100
      max_delay_ms: 5000
      backoff_multiplier: 2.0

    circuit_breaker:
      failure_threshold: 5
      recovery_timeout_ms: 30000
      half_open_requests: 3

    dead_letter:
      enabled: true
      queue: "agent-dead-letter"
      retention_days: 7

# =============================================================================
# Monitoring & Observability
# =============================================================================
monitoring:
  tracing:
    enabled: true
    provider: "opentelemetry"
    exporter: "jaeger"
    sampling_rate: 1.0

  metrics:
    enabled: true
    provider: "prometheus"
    scrape_interval: "15s"

    custom_metrics:
      - name: "agent_task_duration_seconds"
        type: "histogram"
        labels: ["agent_id", "task_type", "status"]
        buckets: [0.1, 0.5, 1.0, 2.5, 5.0, 10.0, 30.0, 60.0]

      - name: "agent_task_total"
        type: "counter"
        labels: ["agent_id", "task_type", "status"]

      - name: "agent_concurrent_tasks"
        type: "gauge"
        labels: ["agent_id"]

      - name: "soap_request_duration_seconds"
        type: "histogram"
        labels: ["service", "operation", "status"]
        buckets: [0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0]

  logging:
    level: "info"
    format: "json"
    include_trace_id: true

  alerts:
    - name: "agent_high_error_rate"
      condition: "error_rate > 5%"
      severity: "critical"

    - name: "agent_high_latency"
      condition: "p99_latency > 10s"
      severity: "warning"

    - name: "soap_service_unavailable"
      condition: "health_check_failed"
      severity: "critical"

# =============================================================================
# Security Boundaries
# =============================================================================
security:
  authentication:
    agents:
      method: "mTLS"
      certificate_path: "/certs/agent.crt"
      key_path: "/certs/agent.key"
      ca_path: "/certs/ca.crt"

    external:
      method: "JWT"
      issuer: "semantic-kernel-app"
      audience: "semantic-kernel-api"

  authorization:
    model: "RBAC"
    policies:
      - name: "agent-to-agent"
        subjects: ["agent-*"]
        resources: ["agent-*"]
        actions: ["invoke", "query"]

      - name: "external-to-orchestrator"
        subjects: ["external-client"]
        resources: ["agent-orchestrator"]
        actions: ["invoke"]

  data_protection:
    encryption_at_rest: true
    encryption_in_transit: true
    pii_masking: true
    audit_logging: true

# =============================================================================
# Cross-References
# =============================================================================
related_documentation:
  - ".config/architecture.yml: Overall architecture"
  - ".config/services.yml: Service configurations"
  - ".config/tracing.yml: Observability configuration"
  - "src/engine/: Semantic Kernel engine implementation"
  - "src/business/: Business layer with agent coordination"
